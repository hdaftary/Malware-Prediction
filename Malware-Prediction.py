# -*- coding: utf-8 -*-
"""Harshal Daftary - cse519-113278112.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q35PIz4GcJA2v5IFuiMqLS8ubG2Kug-k

## <u>**Use the "Text" blocks to provide explanations wherever you find them necessary. Highlight your answers inside these text fields to ensure that we don't miss it while grading your HW.**</u>

## **Setup**

- Code to download the data directly from the colab notebook.
- If you find it easier to download the data from the kaggle website (and uploading it to your drive), you can skip this section.
"""

!pip install -q kaggle

from google.colab import files
# Create a new API token under "Account" in the kaggle webpage and download the json file
# Upload the file by clicking on the browse 
files.upload()

mkdir -p ~/.kaggle/ && mv kaggle.json ~/.kaggle/ && chmod 600 ~/.kaggle/kaggle.json

!kaggle competitions download -c microsoft-malware-prediction

"""## **Section 1: Library and Data Imports (Q1)**

- Import your libraries and read the data into a dataframe. Print the head of the dataframe. 
"""

use_cols = ["MachineIdentifier", "SmartScreen", "AVProductsInstalled", "AppVersion", "CountryIdentifier", "Census_OSInstallTypeName", "Wdft_IsGamer",
           "EngineVersion", "AVProductStatesIdentifier", "Census_OSVersion", "Census_TotalPhysicalRAM", "Census_ActivationChannel",
           "RtpStateBitfield", "Census_ProcessorModelIdentifier", "Census_PrimaryDiskTotalCapacity", 
            "Census_InternalPrimaryDiagonalDisplaySizeInInches", "Wdft_RegionIdentifier", "LocaleEnglishNameIdentifier",
           "AvSigVersion", "IeVerIdentifier", "IsProtected", "Census_InternalPrimaryDisplayResolutionVertical", "Census_PrimaryDiskTypeName",
            "Census_OSWUAutoUpdateOptionsName", "Census_OSEdition", "Census_GenuineStateName", "Census_ProcessorCoreCount", 
           "Census_OEMNameIdentifier", "Census_MDC2FormFactor", "Census_FirmwareManufacturerIdentifier", "OsBuildLab", "Census_OSBuildRevision", 
            "Census_OSBuildNumber", "Census_IsPenCapable", "Census_IsTouchEnabled", "Census_IsAlwaysOnAlwaysConnectedCapable", "Census_IsSecureBootEnabled", 
            "Census_SystemVolumeTotalCapacity", "Census_PrimaryDiskTotalCapacity", "HasDetections"
           ]
dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float16',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryIdentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int8',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float32',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float16',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float16',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float64',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float64',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float64',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16'        
        }

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import gc
sns.set(rc = {'figure.figsize':(15,8)})

!unzip train.csv.zip
# !unzip test.csv.zip

df = pd.read_csv('train.csv', usecols=use_cols, dtype=dtypes)

df.head()

df.corr()['HasDetections']

"""Thus, the baseline model I will use shall have a total of 6 numeric features, which are most likely to have an effect on 'HasDetections'.

1. AVProductsInstalled (number of antivirus products installed)
2. AVProductStatesIdentifier (which antivirus is installed)
3. Census_IsAlwaysOnAlwaysConnectedCapable  (whether the battery enables the device to be AlwaysOnAlwaysConnected)
4. IsProtected (returns: a. TRUE if there is at least one active and up-to-date antivirus product running on this machine. b. FALSE if there is no active AV product on this machine, or if the AV is active, but is not receiving the latest updates. c. null if there are no Anti Virus Products in the report. Returns: Whether a machine is protected
5. Census_TotalPhysicalRAM (Retrieves the physical RAM in MB)
6. Census_ProcessorCoreCount (Number of cores in machine)
7. Census_OSBuildNumber (extracted from the OsVersionFull which OS used should have an effect on accuracy).
"""

baseline_cols = ['AVProductsInstalled', 'AVProductStatesIdentifier', 'Census_IsAlwaysOnAlwaysConnectedCapable', 'IsProtected', 'Census_TotalPhysicalRAM', 'Census_ProcessorCoreCount', 'Census_OSBuildNumber']

"""## **Section 2: Measure of Power (Q2a & 2b)**

Columns to be considered when deciding the power of the PC

1. Census_ProcessorCoreCount (more number of processors means more powerful)
2. Census_TotalPhysicalRAM (more is better)
3.Census_PrimaryDiskTypeName (SSD is more powerful than HDD)                                                        
4. Wdft_IsGamer (Gaming machines are more powerful)
"""

for feature in ['Census_ProcessorCoreCount', 'Census_TotalPhysicalRAM', 'Census_PrimaryDiskTypeName', 'Wdft_IsGamer']:
  print(df[feature].value_counts())
  print("\n")

"""For processors and RAM, I have taken the log to base of a very low value in each category to get a relative number instead of absolute number. And I added 1 to power if the computer has SSD and 1 if it is a gaming PC. I thought to make code more clean and easy to comprehend but storing each value in unnecessary variables was causing colab to crash"""

df['Power'] = np.log(df['Census_ProcessorCoreCount']) / np.log(2) + np.log(df['Census_TotalPhysicalRAM']) / np.log(2048) + (df['Census_PrimaryDiskTypeName'] == 'SSD').replace({False: 0, True:1}) + df['Wdft_IsGamer']

df['Power']

"""Distribution of powerful machines"""

df['Power'].plot.hist(bins=15, alpha=0.5)

# Checking how many powerful machines have malware. Here, I have considered Power > 4 to be a powerful machine
condition_malware_powerful = (df['Power'] >= 4) & (df['HasDetections'] == 1)
np.count_nonzero(condition_malware_powerful) / np.count_nonzero(df['Power'] >= 4)

"""Based on above value, it seems that power of a computer does not determine if a computer is more or less likely to be infected

Plotting
"""

sns.violinplot(x="HasDetections", y="Power", data=df)

"""## **Section 3: OS version vs Malware detected (Q3)**

We are not plotting those with value_count very small because it will distort the plot and we cant gain any insights from them
"""

sns.countplot(x="Census_OSBuildNumber", hue="HasDetections", data=df[df['HasDetections'] == 1], order=df.Census_OSBuildNumber.value_counts().iloc[:10].index)

malware_infected_build_number = df.groupby('Census_OSBuildNumber')['HasDetections'].value_counts(normalize=True).mul(100).rename('percent').reset_index()
malware_infected_build_number[malware_infected_build_number['HasDetections'] == 1]

sns.barplot(x="Census_OSBuildNumber", y="percent", data=malware_infected_build_number[malware_infected_build_number['HasDetections'] == 1], order=df.Census_OSBuildNumber.value_counts().iloc[:20].index)

sns.countplot(x="Census_OSBuildRevision", data=df[df['HasDetections'] == 1], order=df.Census_OSBuildRevision.value_counts().iloc[:20].index)

malware_infected_build_revision = df.groupby('Census_OSBuildRevision')['HasDetections'].value_counts(normalize=True).mul(100).rename('percent').reset_index()
malware_infected_build_revision[malware_infected_build_revision['HasDetections'] == 1]

sns.barplot(x="Census_OSBuildRevision", y="percent", data=malware_infected_build_revision[malware_infected_build_revision['HasDetections'] == 1], order=df.Census_OSBuildRevision.value_counts().iloc[:20].index)

"""Additional: Comparison between y=0 and y=1 is shown below"""

# 17134    50
# 16299    23
# 15063     9
# 10586     8
# 14393     7
# 10240     3
# Name: Census_OSBuildNumber, dtype: int64
sns.countplot(x="Census_OSBuildNumber", hue="HasDetections", data=df, order=df.Census_OSBuildNumber.value_counts().iloc[:10].index)

(df
.groupby('Census_OSBuildRevision')['HasDetections']
.value_counts(normalize=True)
.mul(100)
.rename('percent')
.reset_index()
.pipe((sns.catplot,'data'), x='Census_OSBuildRevision',y='percent',hue='HasDetections',kind='bar', order=df.Census_OSBuildRevision.value_counts().iloc[:20].index))

"""## **Section 4: Effect of Number of AV Products Installed (Q4)**"""

print("Machines which are not protected and not infected with malware =", np.count_nonzero((df['IsProtected'] == 0) & (df['HasDetections'] == 0)))
print("Machines which are not protected and infected with malware =", np.count_nonzero((df['IsProtected'] == 0) & (df['HasDetections'] == 1)))
print("Machines which are protected and not infected with malware =", np.count_nonzero((df['IsProtected'] == 1) & (df['HasDetections'] == 0)))
print("Machines which are protected and infected with malware =", np.count_nonzero((df['IsProtected'] == 1) & (df['HasDetections'] == 1)))

"""Thus, based on above statistics, it seems that there is no effect of having a antivirus in chances of the machine getting infected with malware"""

sns.countplot(x='AVProductsInstalled', hue='HasDetections',data=df[df['AVProductsInstalled'] > 0 ]).set_yscale("log")

"""From above graph, it seems that if the machine has 1 anti virus, then chances if it getting infected is more but as number of antivirus increases, malware detections in machine decreases (except for when AVProductsInstalled = 7, which is an outlier I believe since there is only 1 machine in the entire dataset. Thus number of AV products matter.

## **Section 5: Interesting findings (Q5)**
"""

del df
gc.collect()

df = pd.read_csv('train.csv', usecols=["IsSxsPassiveMode", "PuaMode", "SMode", "Platform", "HasDetections"], dtype=dtypes)

"""1. SxS Passive Mode means Microsoft Defender Antivirus is running alongside another antivirus/antimalware product. Thus, when a machine is having one third party antivirus installed alongside Windows Defender, it has very less chances of getting infected with malware."""

sns.countplot(x='IsSxsPassiveMode', hue='HasDetections', data=df)
plt.yscale('log')
plt.title('Infected Machines vs Passive Mode')
plt.show()

"""2. Should we enable PUA mode as recommended by windows? From their website "The Potentially Unwanted Applications (PUA) protection feature in Microsoft Defender Antivirus can identify and block PUAs from downloading and installing on endpoints in your network." The plots seem to show something else that if PUA is on, then relatively more machines are infected with malware."""

sns.countplot(x='PuaMode', hue='HasDetections', data=df)
plt.title('Infected Machines vs PUA Protection Mode', size=15)
plt.show()

"""3. It is very difficult to be infected with malware with S mode enabled. Thus, Microsoft's claim that "Windows 10 in S mode is a version of Windows 10 that's streamlined for security and performance" is correct. """

plt.figure(figsize=(15,10))
sns.countplot(x='SMode', hue='HasDetections', data=df)
plt.title('Infected Machines vs Secure Mode', size=15)
plt.yscale('log')
plt.show()

"""4. It seems that windows 2016 has very less computers infected with malware as compared to other platforms."""

plt.figure(figsize=(15,10))
sns.countplot(x='Platform', hue='HasDetections', data=df)
plt.title('Impact of the Operating System', size=15)
plt.yscale('log')
plt.show()

"""## **Section 6: Baseline modelling (Q6)**"""

del df
gc.collect()

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score
import joblib

"""Features I feel are useful, and thus used in baseline model are mentioned in variable baseline_cols"""

baseline_cols

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
df = pd.read_csv('train.csv', usecols=baseline_cols + ['HasDetections'], dtype=dtypes)
df.dropna(inplace=True)
X = df[baseline_cols]
y = df[['HasDetections']]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
clf = LogisticRegression(random_state=0).fit(X_train, y_train)
print("Accuracy of baseline model is ", clf.score(X_test, y_test))

print("Error rate is 1 - accuracy = ", 1 - clf.score(X_test, y_test))
print("AUC score is ", roc_auc_score(y_test, clf.decision_function(X_test)))

joblib.dump(clf, 'logistic_base.pkl')

"""## **Section 7: Feature Cleaning and Additional models (Q7a & 7b)**"""

advance_models = ['AVProductsInstalled',
 'AVProductStatesIdentifier',
 'Census_IsAlwaysOnAlwaysConnectedCapable',
 'IsProtected',
 'Census_TotalPhysicalRAM',
 'Census_ProcessorCoreCount',
 'Census_OSBuildNumber',
 'Census_PrimaryDiskTypeName',
 'Census_InternalPrimaryDiagonalDisplaySizeInInches',
 'Census_InternalPrimaryDisplayResolutionVertical']

del df
gc.collect()

df = pd.read_csv('train.csv', usecols=advance_models + ['HasDetections'], dtype=dtypes)
med = df.median()
mde = df.mode()
df.fillna(med, inplace=True) #Replace missing numerical values with median, this does not handle categorical values
df.fillna(mde, inplace=True) #Replace missing categorical values with mode

#Census_OSBuildNumber should be converted to one-hot encoding for further processing
#We will only consider those which appear more than 10000 times, else number of columns in dataframe will be very much

less_common_build_number = df.Census_OSBuildNumber.value_counts()
list_more_common_build_number = less_common_build_number[less_common_build_number > 10000].index.to_list()
for i, v in df['Census_OSBuildNumber'].items():
  if v not in list_more_common_build_number:
    df.at[i, 'Census_OSBuildNumber'] = 0

os_build_number = pd.get_dummies(df.Census_OSBuildNumber, prefix='OSBuildNumber')
df = pd.concat([df, os_build_number], axis=1)
del df['OSBuildNumber_0']
del df['Census_OSBuildNumber']

gc.collect()

#Similarly, AVProductStatesIdentifier should be converted to one-hot encoding for further processing
#We will only consider those which appear more than 80000 times, else number of columns in dataframe will be very much

less_common_build_number = df.AVProductStatesIdentifier.value_counts()
list_more_common_build_number = less_common_build_number[less_common_build_number > 80000].index.to_list()
for i, v in df['AVProductStatesIdentifier'].items():
  if v not in list_more_common_build_number:
    df.at[i, 'AVProductStatesIdentifier'] = 0

os_build_number = pd.get_dummies(df.AVProductStatesIdentifier, prefix='AVProductID')
df = pd.concat([df, os_build_number], axis=1)
del df['AVProductID_0.0']
del df['AVProductStatesIdentifier']

gc.collect()

storage_type = pd.get_dummies(df.Census_PrimaryDiskTypeName, prefix='Storage')
df = pd.concat([df, storage_type], axis=1)
del df['Census_PrimaryDiskTypeName']
gc.collect()

"""Census_InternalPrimaryDiagonalDisplaySizeInInches and Census_InternalPrimaryDisplayResolutionVertical can be an important feature too because sometimes 
https://www.makeuseof.com/tag/malware-uses-screen-resolution-avoid-detection/
"""

print("Missing values in Census_InternalPrimaryDisplayResolutionVertical", df.Census_InternalPrimaryDisplayResolutionVertical.isna().sum())
print("Missing values in Census_InternalPrimaryDiagonalDisplaySizeInInches", df.Census_InternalPrimaryDiagonalDisplaySizeInInches.isna().sum())

from sklearn.preprocessing import StandardScaler #Not used as none of the distributions are Normal as evident from plots
from sklearn.preprocessing import MinMaxScaler #MinMaxScaler may be used when the upper and lower boundaries are well known from domain knowledge 
from sklearn.preprocessing import RobustScaler # For Processor and RAM as df.col_name.hist() shows very skewed distribution

print("Replacing erratic value of having -1 resolution by median ",df.Census_InternalPrimaryDisplayResolutionVertical.median())
for i, v in df['Census_InternalPrimaryDisplayResolutionVertical'].items():
  if v == -1.0:
    df.at[i, 'Census_InternalPrimaryDisplayResolutionVertical'] = 768.0

scalar1 = MinMaxScaler()
scalar2 = MinMaxScaler()
df.Census_InternalPrimaryDisplayResolutionVertical = scalar1.fit_transform(df.Census_InternalPrimaryDisplayResolutionVertical.values.reshape(-1, 1))
df.Census_InternalPrimaryDiagonalDisplaySizeInInches = scalar2.fit_transform(df.Census_InternalPrimaryDiagonalDisplaySizeInInches.values.reshape(-1, 1))

scalar3 = RobustScaler()
scalar4 = RobustScaler()
df.Census_ProcessorCoreCount = scalar3.fit_transform(df.Census_ProcessorCoreCount.values.reshape(-1, 1))
df.Census_TotalPhysicalRAM = scalar4.fit_transform(df.Census_TotalPhysicalRAM.values.reshape(-1, 1))

print("Missing values in RAM", df.Census_TotalPhysicalRAM.isna().sum())
print("Missing values in ProcessorCount", df.Census_ProcessorCoreCount.isna().sum())

X = df.drop('HasDetections', axis=1)
y = df[['HasDetections']]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
clf = LogisticRegression(random_state=0).fit(X_train, y_train)
print("Accuracy of advance logistic regression is ", clf.score(X_test, y_test))

print("Error rate is 1 - accuracy = ", 1 - clf.score(X_test, y_test))
print("AUC score is ", roc_auc_score(y_test, clf.decision_function(X_test)))

joblib.dump(clf, 'logistic_advance.pkl')

"""Advance Model"""

from sklearn.ensemble import RandomForestClassifier
rfc = RandomForestClassifier(random_state=0).fit(X_train, y_train)
print("Accuracy of advance random forest classifier is ", rfc.score(X_test, y_test))

print("Error rate is 1 - accuracy = ", 1 - rfc.score(X_test, y_test))
print("AUC score is ", roc_auc_score(y_test, rfc.predict_proba(X_test)[:,1]))

joblib.dump(rfc, 'random_forest_classifier.pkl')

"""Random Forest Classifier performs better than advance logistic regression because it uses ensemble learning (bagging) to reduce variance in the model, which in turn performs better than baseling model because we have done data pre-processing, handling of missing values, etc.

Error rate in a dataframe table
"""

dataerr = [['baseline_logistic_regression', 0.45812597202836225], ['advance_logistic_regression', 0.4128096387540864], ['random_forest_classifier', 0.4063886225219232]]
pd.DataFrame(dataerr, columns = ['Model', 'Error Rate'])

"""## **Section 8: Screenshots (Q8)** """

del df
gc.collect()

!unzip test.csv.zip

df_test = pd.read_csv('test.csv',usecols=advance_models,dtype=dtypes)

df_test.fillna(med, inplace=True) #Replace missing numerical values with median of TRAIN data
df_test.fillna(mde, inplace=True) #Replace missing categorical values with mode of TRAIN data


less_common_build_number = df_test.Census_OSBuildNumber.value_counts()
list_more_common_build_number = less_common_build_number[less_common_build_number > 30000].index.to_list()
for i, v in df_test['Census_OSBuildNumber'].items():
  if v not in list_more_common_build_number:
    df_test.at[i, 'Census_OSBuildNumber'] = 0

os_build_number = pd.get_dummies(df_test.Census_OSBuildNumber, prefix='OSBuildNumber')
df_test = pd.concat([df_test, os_build_number], axis=1)
del df_test['OSBuildNumber_0']
del df_test['Census_OSBuildNumber']

gc.collect()


#Similarly, AVProductStatesIdentifier should be converted to one-hot encoding for further processing
#We will only consider those which appear more than 80000 times, else number of columns in dataframe will be very much

less_common_build_number = df_test.AVProductStatesIdentifier.value_counts()
list_more_common_build_number = less_common_build_number[less_common_build_number > 80000].index.to_list()
for i, v in df_test['AVProductStatesIdentifier'].items():
  if v not in list_more_common_build_number:
    df_test.at[i, 'AVProductStatesIdentifier'] = 0

os_build_number = pd.get_dummies(df_test.AVProductStatesIdentifier, prefix='AVProductID')
df_test = pd.concat([df_test, os_build_number], axis=1)
del df_test['AVProductID_0.0']
del df_test['AVProductStatesIdentifier']

gc.collect()


storage_type = pd.get_dummies(df_test.Census_PrimaryDiskTypeName, prefix='Storage')
df_test = pd.concat([df_test, storage_type], axis=1)
del df_test['Census_PrimaryDiskTypeName']
gc.collect()



print("Replacing erratic value of having -1 resolution by median from TRAIN data")
for i, v in df_test['Census_InternalPrimaryDisplayResolutionVertical'].items():
  if v == -1.0:
    df_test.at[i, 'Census_InternalPrimaryDisplayResolutionVertical'] = 768.0


df_test.Census_InternalPrimaryDisplayResolutionVertical = scalar1.transform(df_test.Census_InternalPrimaryDisplayResolutionVertical.values.reshape(-1, 1))
df_test.Census_InternalPrimaryDiagonalDisplaySizeInInches = scalar2.transform(df_test.Census_InternalPrimaryDiagonalDisplaySizeInInches.values.reshape(-1, 1))

df_test.Census_ProcessorCoreCount = scalar3.transform(df_test.Census_ProcessorCoreCount.values.reshape(-1, 1))
df_test.Census_TotalPhysicalRAM = scalar4.transform(df_test.Census_TotalPhysicalRAM.values.reshape(-1, 1))

"""Note: On analysing the columns of df_test, and comparing with columns of df, we can see OSBuildNumber_17763 but that is not there in our training data. So, the best way is to drop the column"""

df_test.drop('OSBuildNumber_17763',axis=1,inplace=True)

"""Also, the test data does not have some of our one-hot encoded features. Thus, since the model is already trained, I am creating a new feature with value = 0, so that it does not affect training"""

for av in ['AVProductID_23657.0', 'AVProductID_41571.0', 'AVProductID_46413.0']:
  df_test[av] = 0

gc.collect()

print(df_test.columns)
X_train.columns

!unzip sample_submission.csv.zip

submission = pd.read_csv('sample_submission.csv')
submission['HasDetections'] = rfc.predict_proba(df_test)[:,1]
submission.to_csv('randomforest_submission.csv', index=False)

gc.collect()
submission['HasDetections'] = clf.predict_proba(df_test)[:,1]
submission.to_csv('logistic_advance_submission.csv', index=False)

clf = joblib.load('logistic_base.pkl')

del df_test
gc.collect()

del X
del y
del X_train
del y_train
gc.collect()

del df_test
gc.collect()

#df_test = pd.read_csv('test.csv', usecols=baseline_cols, dtype=dtypes)
df_test.fillna(df_test.median(), inplace=True) #Replace missing values with median 
submission['HasDetections'] = clf.predict_proba(df_test)[:,1]
submission.to_csv('logistic_base_submission.csv', index=False)

"""logistic_base_submission.csv
0.54580 Private
0.53650 Public


logistic_advance_submission.csv
0.53629 Private
0.59341 Public


randomforest_submission.csv
0.52749 Private
0.55494 Public

Kaggle profile link: https://www.kaggle.com/harshaldaftar

Screenshot(s): [!picture](https://drive.google.com/file/d/16sDX2HXVs6pUFmNoSMkHKA8h01eNErar/view?usp=sharing)
"""

from IPython.display import Image
Image("kaggle.PNG", width=1200)